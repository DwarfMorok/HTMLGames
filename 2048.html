<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>2048</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            font-family: Arial, sans-serif;
            color: white;
        }

        h1 {
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            margin-bottom: 10px;
        }

        .score-panel {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            font-size: 20px;
            font-weight: bold;
        }

        .score {
            color: #4ecdc4;
        }

        .best {
            color: #ffd166;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(4, 100px);
            grid-template-rows: repeat(4, 100px);
            gap: 10px;
            background: #bbada0;
            padding: 10px;
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
        }

        .cell {
            width: 100px;
            height: 100px;
            background: rgba(238, 228, 218, 0.35);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 35px;
            font-weight: bold;
        }

        .tile {
            position: absolute;
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 35px;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.15s ease-out;
            z-index: 2;
        }

        button {
            padding: 12px 25px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px;
        }

            button:hover {
                background: #ff5252;
                transform: scale(1.05);
            }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ff6b6b;
            text-align: center;
            display: none;
            z-index: 100;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            opacity: 0.8;
        }

        /* –ö—Ä–∞—Å–æ—Ç—É–ª—å–∫–∏ */
        .tile-2 {
            background: #eee4da;
            color: #776e65;
        }

        .tile-4 {
            background: #ede0c8;
            color: #776e65;
        }

        .tile-8 {
            background: #f2b179;
            color: white;
        }

        .tile-16 {
            background: #f59563;
            color: white;
        }

        .tile-32 {
            background: #f67c5f;
            color: white;
        }

        .tile-64 {
            background: #f65e3b;
            color: white;
        }

        .tile-128 {
            background: #edcf72;
            color: white;
            font-size: 30px;
        }

        .tile-256 {
            background: #edcc61;
            color: white;
            font-size: 30px;
        }

        .tile-512 {
            background: #edc850;
            color: white;
            font-size: 30px;
        }

        .tile-1024 {
            background: #edc53f;
            color: white;
            font-size: 25px;
        }

        .tile-2048 {
            background: #edc22e;
            color: white;
            font-size: 25px;
        }

        .tile-super {
            background: #3c3a32;
            color: white;
            font-size: 20px;
        }

        /* –ê–Ω–∏–º–∞—à–∫–∏ */
        @keyframes appear {
            0% {
                transform: scale(0);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        .new-tile {
            animation: appear 0.2s;
        }

        @keyframes merge {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        .merged-tile {
            animation: merge 0.2s;
        }
    </style>
</head>
<body>
    <h1>üî¢ 2048 - –°–æ–±–∏—Ä–∞–π –∏ –æ–±—ä–µ–¥–∏–Ω—è–π!</h1>

    <div class="score-panel">
        <div class="score">–°—á–µ—Ç: <span id="score">0</span></div>
        <div class="best">–†–µ–∫–æ—Ä–¥: <span id="best">0</span></div>
    </div>

    <div id="game-board">
        <!-- –ö–ª–µ—Ç–æ—á–∫–∏ -->
    </div>

    <div>
        <button onclick="startGame()">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
        <button onclick="undoMove()">–û—Ç–º–µ–Ω–∏—Ç—å —Ö–æ–¥</button>
    </div>

    <div class="controls">
        <div>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üê ‚Üë ‚Üí ‚Üì –∏–ª–∏ WASD</div>
    </div>

    <div class="message" id="message"></div>

    <script>
        const boardSize = 4;
        let gameState = {
            board: [],
            score: 0,
            bestScore: localStorage.getItem('2048-best') || 0,
            gameOver: false,
            gameWon: false,
            previousState: null
        };

        // –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
        function initGame() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';

            // –°–µ—Ç–æ—á–∫–∞
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${i}`;
                gameBoard.appendChild(cell);
            }

            // –ò–Ω–∏–∞—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª—è
            gameState.board = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
            gameState.score = 0;
            gameState.gameOver = false;
            gameState.gameWon = false;
            gameState.previousState = null;

            // –ü–µ—Ä–≤—ã–µ –¥–≤–µ –ø–ª–∏—Ç–∫–∏
            addRandomTile();
            addRandomTile();

            updateUI();
            renderBoard();
        }

        // + —Å–ª—É—á–∞–π–Ω–∞—è –ø–ª–∏—Ç–∫–∞
        function addRandomTile() {
            const emptyCells = [];

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (gameState.board[row][col] === 0) {
                        emptyCells.push({ row, col });
                    }
                }
            }

            if (emptyCells.length > 0) {
                const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                gameState.board[row][col] = Math.random() < 0.9 ? 2 : 4;
                playSound('new');
            }
        }

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–ª–∏—Ç–æ–∫
        function renderBoard() {
            const gameBoard = document.getElementById('game-board');

            // —É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä—å—è
            document.querySelectorAll('.tile').forEach(tile => tile.remove());

            // –º–æ–ª–æ–¥–Ω—è–∫
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const value = gameState.board[row][col];
                    if (value > 0) {
                        const tile = document.createElement('div');
                        tile.className = `tile tile-${value}`;
                        if (value > 2048) tile.classList.add('tile-super');

                        tile.textContent = value;
                        tile.style.left = `${col * 110 + 10}px`;
                        tile.style.top = `${row * 110 + 10}px`;

                        gameBoard.appendChild(tile);
                    }
                }
            }
        }

        // –î–≤–∏–∂–µ–Ω–∏–µ
        function move(direction) {
            if (gameState.gameOver) return;

            // –°–æ—Ö—Ä –ø—Ä–µ–¥ —Å–æ—Å—Ç
            gameState.previousState = {
                board: JSON.parse(JSON.stringify(gameState.board)),
                score: gameState.score
            };

            let boardChanged = false;

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è
            switch (direction) {
                case 'left':
                    boardChanged = moveLeft();
                    break;
                case 'up':
                    boardChanged = moveUp();
                    break;
                case 'right':
                    boardChanged = moveRight();
                    break;
                case 'down':
                    boardChanged = moveDown();
                    break;
            }

            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ = –Ω–æ–≤–∞—è –ø–ª–∏—Ç–∫–∞
            if (boardChanged) {
                addRandomTile();
                checkGameOver();
                updateUI();
                renderBoard();
            }
        }

        // –í–ª–µ–≤–æ
        function moveLeft() {
            let changed = false;
            for (let row = 0; row < boardSize; row++) {
                // –°–±–æ—Ä–∫–∞ –≤—Å—è–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                const nonZero = gameState.board[row].filter(cell => cell !== 0);
                const newRow = [];
                let i = 0;

                // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–æ—Å–µ–¥–Ω–∏—Ö –ø–ª–∏—Ç–æ–∫
                while (i < nonZero.length) {
                    if (i < nonZero.length - 1 && nonZero[i] === nonZero[i + 1]) {
                        // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ
                        newRow.push(nonZero[i] * 2);
                        gameState.score += nonZero[i] * 2;
                        playSound('merge');
                        i += 2;

                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã
                        if (nonZero[i] * 2 === 2048 && !gameState.gameWon) {
                            gameState.gameWon = true;
                            showMessage('üéâ –ü–û–ë–ï–î–ê! –¢—ã –ø–æ–ª—É—á–∏–ª 2048! üéâ');
                            playSound('win');
                        }
                    } else {
                        // –î–≤–∏–∂–µ–Ω–∏–µ –ø–ª–∏—Ç–∫–∏
                        newRow.push(nonZero[i]);
                        i += 1;
                    }
                }

                while (newRow.length < boardSize) {
                    newRow.push(0);
                }

                for (let col = 0; col < boardSize; col++) {
                    if (gameState.board[row][col] !== newRow[col]) {
                        changed = true;
                    }
                }

                // –û–±–Ω–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫–∏
                gameState.board[row] = newRow;
            }
            return changed;
        }

        // –í–≤–µ—Ä—Ö
        function moveUp() {
            let changed = false;
            for (let col = 0; col < boardSize; col++) {
                // –°–±–æ—Ä–∫–∞ –≤—Å—è–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                const nonZero = [];
                for (let row = 0; row < boardSize; row++) {
                    if (gameState.board[row][col] !== 0) {
                        nonZero.push(gameState.board[row][col]);
                    }
                }

                const newCol = [];
                let i = 0;

                // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–æ—Å–µ–¥–Ω–∏—Ö –ø–ª–∏—Ç–æ–∫
                while (i < nonZero.length) {
                    if (i < nonZero.length - 1 && nonZero[i] === nonZero[i + 1]) {
                        newCol.push(nonZero[i] * 2);
                        gameState.score += nonZero[i] * 2;
                        playSound('merge');
                        i += 2;
                    } else {
                        newCol.push(nonZero[i]);
                        i += 1;
                    }
                }

                while (newCol.length < boardSize) {
                    newCol.push(0);
                }

                for (let row = 0; row < boardSize; row++) {
                    if (gameState.board[row][col] !== newCol[row]) {
                        changed = true;
                        gameState.board[row][col] = newCol[row];
                    }
                }
            }
            return changed;
        }

        // –í–ø—Ä–∞–≤–æ
        function moveRight() {
            let changed = false;
            for (let row = 0; row < boardSize; row++) {
                // –°–±–æ—Ä–∫–∞ –≤—Å—è–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                const nonZero = gameState.board[row].filter(cell => cell !== 0);
                const newRow = [];
                let i = nonZero.length - 1;

                // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–æ—Å–µ–¥–Ω–∏—Ö –ø–ª–∏—Ç–æ–∫
                while (i >= 0) {
                    if (i > 0 && nonZero[i] === nonZero[i - 1]) {
                        // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ
                        newRow.unshift(nonZero[i] * 2);
                        gameState.score += nonZero[i] * 2;
                        playSound('merge');
                        i -= 2;
                    } else {
                        newRow.unshift(nonZero[i]);
                        i -= 1;
                    }
                }

                while (newRow.length < boardSize) {
                    newRow.unshift(0);
                }

                for (let col = 0; col < boardSize; col++) {
                    if (gameState.board[row][col] !== newRow[col]) {
                        changed = true;
                    }
                }

                gameState.board[row] = newRow;
            }
            return changed;
        }

        // –í–Ω–∏–∑
        function moveDown() {
            let changed = false;
            for (let col = 0; col < boardSize; col++) {
                // –°–±–æ—Ä–∫–∞ –≤—Å—è–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
                const nonZero = [];
                for (let row = boardSize - 1; row >= 0; row--) {
                    if (gameState.board[row][col] !== 0) {
                        nonZero.push(gameState.board[row][col]);
                    }
                }

                const newCol = [];
                let i = 0;

                // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–æ—Å–µ–¥–Ω–∏—Ö –ø–ª–∏—Ç–æ–∫
                while (i < nonZero.length) {
                    if (i < nonZero.length - 1 && nonZero[i] === nonZero[i + 1]) {
                        newCol.push(nonZero[i] * 2);
                        gameState.score += nonZero[i] * 2;
                        playSound('merge');
                        i += 2;
                    } else {
                        newCol.push(nonZero[i]);
                        i += 1;
                    }
                }

                while (newCol.length < boardSize) {
                    newCol.push(0);
                }

                newCol.reverse();
                for (let row = 0; row < boardSize; row++) {
                    if (gameState.board[row][col] !== newCol[row]) {
                        changed = true;
                        gameState.board[row][col] = newCol[row];
                    }
                }
            }
            return changed;
        }

        function checkGameOver() {
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (gameState.board[row][col] === 0) {
                        return;
                    }
                }
            }

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const current = gameState.board[row][col];

                    if (col < boardSize - 1 && gameState.board[row][col + 1] === current) return;
                    if (row < boardSize - 1 && gameState.board[row + 1][col] === current) return;
                }
            }

            // –ü—Ä–æ–∏–≥—Ä—ã—à
            gameState.gameOver = true;
            showMessage('üíÄ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑! üíÄ');
            playSound('lose');
        }

        function undoMove() {
            if (gameState.previousState && !gameState.gameOver) {
                gameState.board = gameState.previousState.board;
                gameState.score = gameState.previousState.score;
                gameState.previousState = null;
                updateUI();
                renderBoard();
                playSound('undo');
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;

            if (gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem('2048-best', gameState.bestScore);
            }
            document.getElementById('best').textContent = gameState.bestScore;
        }

        function startGame() {
            initGame();
        }

        function showMessage(text) {
            const messageElement = document.getElementById('message');
            messageElement.textContent = text;
            messageElement.style.display = 'block';

            setTimeout(() => {
                messageElement.style.display = 'none';
            }, 3000);
        }

        function playSound(type) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();

            switch (type) {
                case 'new':
                    const newOsc = audioContext.createOscillator();
                    const newGain = audioContext.createGain();
                    newOsc.connect(newGain);
                    newGain.connect(audioContext.destination);
                    newOsc.frequency.setValueAtTime(400, audioContext.currentTime);
                    newGain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    newGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    newOsc.start(audioContext.currentTime);
                    newOsc.stop(audioContext.currentTime + 0.1);
                    break;

                case 'merge':
                    const mergeOsc = audioContext.createOscillator();
                    const mergeGain = audioContext.createGain();
                    mergeOsc.connect(mergeGain);
                    mergeGain.connect(audioContext.destination);
                    mergeOsc.frequency.setValueAtTime(600, audioContext.currentTime);
                    mergeGain.gain.setValueAtTime(0.2, audioContext.currentTime);
                    mergeGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    mergeOsc.start(audioContext.currentTime);
                    mergeOsc.stop(audioContext.currentTime + 0.2);
                    break;

                case 'win':
                    [523.25, 659.25, 783.99, 1046.50].forEach((freq, index) => {
                        setTimeout(() => {
                            const winOsc = audioContext.createOscillator();
                            const winGain = audioContext.createGain();
                            winOsc.connect(winGain);
                            winGain.connect(audioContext.destination);
                            winOsc.frequency.setValueAtTime(freq, audioContext.currentTime);
                            winGain.gain.setValueAtTime(0.3, audioContext.currentTime);
                            winGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            winOsc.start(audioContext.currentTime);
                            winOsc.stop(audioContext.currentTime + 0.3);
                        }, index * 150);
                    });
                    break;

                case 'lose':
                    const loseOsc = audioContext.createOscillator();
                    const loseGain = audioContext.createGain();
                    loseOsc.connect(loseGain);
                    loseGain.connect(audioContext.destination);
                    loseOsc.frequency.setValueAtTime(200, audioContext.currentTime);
                    loseOsc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                    loseGain.gain.setValueAtTime(0.2, audioContext.currentTime);
                    loseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    loseOsc.start(audioContext.currentTime);
                    loseOsc.stop(audioContext.currentTime + 0.5);
                    break;

                case 'undo':
                    const undoOsc = audioContext.createOscillator();
                    const undoGain = audioContext.createGain();
                    undoOsc.connect(undoGain);
                    undoGain.connect(audioContext.destination);
                    undoOsc.frequency.setValueAtTime(300, audioContext.currentTime);
                    undoGain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    undoGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    undoOsc.start(audioContext.currentTime);
                    undoOsc.stop(audioContext.currentTime + 0.1);
                    break;
            }
        }

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;

            switch (e.key.toLowerCase()) {
                case 'arrowup': case 'w': case '—Ü':
                    move('up');
                    e.preventDefault();
                    break;
                case 'arrowdown': case 's': case '—ã':
                    move('down');
                    e.preventDefault();
                    break;
                case 'arrowleft': case 'a': case '—Ñ':
                    move('left');
                    e.preventDefault();
                    break;
                case 'arrowright': case 'd': case '–≤':
                    move('right');
                    e.preventDefault();
                    break;
            }
        });

        window.onload = startGame;
    </script>
</body>
</html>