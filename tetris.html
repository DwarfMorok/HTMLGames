<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris — запускается в браузере</title>
  <style>
    :root{--cell:30px}
    body{font-family: Inter, system-ui, sans-serif; background:#111; color:#eee; display:flex; gap:20px; align-items:flex-start; justify-content:center; min-height:100vh; margin:0; padding:24px}
    .board{background:#0b0b0b; padding:12px; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,.6)}
    canvas{background:#071018; display:block; image-rendering:pixelated}
    .sidebar{display:flex; flex-direction:column; gap:12px}
    .card{background:#071826; padding:12px; border-radius:8px; min-width:160px}
    h1{font-size:18px;margin:0 0 8px}
    p{margin:0}
    button{padding:8px 10px;border-radius:8px;border:0;background:#1b9ce6;color:white;cursor:pointer}
    .controls{font-size:13px; color:#9fb6c8}
    .footer{font-size:12px;color:#6f8b98;margin-top:6px}
  </style>
</head>
<body>
  <div class="board">
    <h1>Tetris</h1>
    <canvas id="game" width="300" height="600"></canvas>
  </div>
  <div class="sidebar">
    <div class="card">
      <div><strong>Следующая фигура</strong></div>
      <canvas id="next" width="120" height="120" style="background:#071018;margin-top:8px"></canvas>
    </div>
    <div class="card">
      <div>Очки: <span id="score">0</span></div>
      <div>Уровень: <span id="level">1</span></div>
      <div>Линий: <span id="lines">0</span></div>
    </div>
    <div class="card controls">
      <div><strong>Управление</strong></div>
      <div>← → — перемещение</div>
      <div>↑ — поворот</div>
      <div>↓ — ускорить</div>
      <div>Space — мгновенно опустить</div>
      <div>P — пауза / возобновить</div>
    </div>
    <div class="card">
      <button id="restart">Перезапустить</button>
    </div>
  </div>

<script>

const COLS = 10, ROWS = 20, CELL = 30;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = COLS * CELL; canvas.height = ROWS * CELL;
const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');

// ориентация фигур, мы же прогресивные
const COLORS = ['#000000', '#FF5555', '#55FF55', '#5555FF', '#FFAA00', '#AA55FF', '#55FFFF', '#FFFF55'];

// 4x4 матрицы
const SHAPES = [
  [],
  [[0,1,0],[1,1,1]],         // T
  [[1,1],[1,1]],             // O
  [[0,1,1],[1,1,0]],         // S
  [[1,1,0],[0,1,1]],         // Z
  [[1,0,0],[1,1,1]],         // J
  [[0,0,1],[1,1,1]],         // L
  [[1,1,1,1]]                // I 
];

// духовные скрепы
function rotate(matrix){
  const H = matrix.length, W = matrix[0].length;
  const res = Array.from({length:W},()=>Array(H).fill(0));
  for(let r=0;r<H;r++) for(let c=0;c<W;c++) res[c][H-1-r]=matrix[r][c];
  return res;
}

function clone(a){ return a.map(r=>r.slice()); }

// Основа
let grid, current, next, pos, score=0, lines=0, level=1, dropInterval=800, dropTimer=0, lastTime=0, running=true;

function newGrid(){ return Array.from({length:ROWS},()=>Array(COLS).fill(0)); }

function randomPiece(){
  const id = Math.floor(Math.random()*7)+1;
  // ещё духовные скрепы
  const shape = SHAPES[id].map(r=>r.slice());
  return {id, shape};
}

function spawn(){
  current = next || randomPiece();
  next = randomPiece();
  pos = {x: Math.floor((COLS - current.shape[0].length)/2), y: -1};
  if(collision(current.shape, pos.x, pos.y)){
    // Потрачено
    running=false; alert('Игра окончена! Очки: '+score);
  }
}

function collision(shape, ox, oy){
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(!shape[r][c]) continue;
      const x = ox + c, y = oy + r;
      if(x<0||x>=COLS||y>=ROWS) return true;
      if(y>=0 && grid[y][x]) return true;
    }
  }
  return false;
}

function merge(){
  const s = current.shape;
  for(let r=0;r<s.length;r++) for(let c=0;c<s[r].length;c++){
    if(s[r][c]){
      const x = pos.x + c, y = pos.y + r;
      if(y>=0) grid[y][x]=current.id;
    }
  }
}

function clearLines(){
  let cnt=0;
  for(let r=ROWS-1;r>=0;r--){
    if(grid[r].every(x=>x!==0)){
      grid.splice(r,1);
      grid.unshift(Array(COLS).fill(0));
      cnt++; r++; 
    }
  }
  if(cnt>0){
    lines += cnt;
    score += [0,100,300,700,1500][cnt] || cnt*500;
    
    const newLevel = Math.floor(lines/10)+1;
    if(newLevel>level){ level=newLevel; dropInterval = Math.max(100, 800 - (level-1)*60); }
    updateHUD();
  }
}

function updateHUD(){
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = lines;
}

function hardDrop(){
  while(!collision(current.shape, pos.x, pos.y+1)) pos.y++;
  lockPiece();
}

function lockPiece(){
  merge();
  clearLines();
  spawn();
}

function step(dt){
  if(!running) return;
  dropTimer += dt;
  if(dropTimer > dropInterval){
    dropTimer = 0;
    if(!collision(current.shape, pos.x, pos.y+1)){
      pos.y++;
    } else {
      lockPiece();
    }
  }
}

function draw(){
  // очистка
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#071018'; ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    drawCell(c,r, grid[r][c]);
  }
  const s = current.shape;
  for(let r=0;r<s.length;r++) for(let c=0;c<s[r].length;c++){
    if(s[r][c]){
      const x = pos.x + c, y = pos.y + r;
      if(y>=0) drawCell(x,y, current.id);
    }
  }
  ctx.strokeStyle='rgba(255,255,255,0.03)';
  for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,ROWS*CELL); ctx.stroke(); }
  for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(COLS*CELL,y*CELL); ctx.stroke(); }
}

function drawCell(col, row, id){
  const x = col*CELL, y = row*CELL;
  if(!id) return;
  ctx.fillStyle = COLORS[id];
  ctx.fillRect(x+1,y+1,CELL-2,CELL-2);
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.strokeRect(x+1,y+1,CELL-2,CELL-2);
}

function drawNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  const s = next.shape;
  const size = 20; const ox = 10, oy = 10;
  for(let r=0;r<s.length;r++) for(let c=0;c<s[r].length;c++){
    if(s[r][c]){
      nctx.fillStyle = COLORS[next.id];
      nctx.fillRect(ox + c*size, oy + r*size, size-2, size-2);
    }
  }
}

// управление
window.addEventListener('keydown', e=>{
  if(!running && e.key.toLowerCase()!=='p') return;
  if(e.key === 'ArrowLeft'){
    if(!collision(current.shape, pos.x-1, pos.y)) pos.x--;
  } else if(e.key === 'ArrowRight'){
    if(!collision(current.shape, pos.x+1, pos.y)) pos.x++;
  } else if(e.key === 'ArrowDown'){
    if(!collision(current.shape, pos.x, pos.y+1)) pos.y++;
  } else if(e.key === 'ArrowUp'){
    const r = rotate(current.shape);
    if(!collision(r, pos.x, pos.y)) current.shape = r;
  } else if(e.code === 'Space'){
    e.preventDefault(); hardDrop();
  } else if(e.key.toLowerCase() === 'p'){
    running = !running; if(running) { lastTime = performance.now(); loop(lastTime); }
  }
  draw(); drawNext();
});

// рестарт
document.getElementById('restart').addEventListener('click', ()=>{
  init();
});

function init(){
  grid = newGrid(); score=0; lines=0; level=1; dropInterval=800; dropTimer=0; running=true; updateHUD();
  next = randomPiece(); spawn(); drawNext(); draw(); lastTime = performance.now(); loop(lastTime);
}

function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = ts - lastTime; lastTime = ts;
  if(running){ step(dt); draw(); drawNext(); requestAnimationFrame(loop); }
}

// пуск
init();
</script>
</body>
</html>
